<!--
@element tcg-swipe
@author designbyraychou
@homepage https://github.com/the-control-group/tcg-swipe

**This element is compatible with Polymer 0.5.**

__Example:__

```
	<tcg-swipe id="swipe" isReveal="{{ isReveal }}" xThreshold="{{ xThreshold }}" animationTime="{{ animationTime }}">
		<div touchpad>Overlay Content</div>
		<div left>
			Left Content
			<a href="#" class="close" on-tap="{{ close }}">Close</a>
		</div>
		<div right>
			Right Content
			<a href="#" class="close" on-tap="{{ close }}">Close</a>
		</div>
	</tcg-swipe>
```
# Attributes

#### `isReveal`

Boolean that determines if the left and right content is position right below the touchpad. If `false`, left and right content moves with the touchpad.

#### `xThreshold`

Number that determines if it'll reveal the full content on trackend event. Default is `50` px

#### `animationTime`

Number in milliseconds for animation length

# Methods

#### `close`

Resets the positions

-->
<link rel="import" href="../polymer/polymer.html">
<polymer-element name="tcg-swipe" attributes="isReveal xThreshold animationTime allowedSwipeDirection startingZIndex onSwipeLeft onSwipeRight onSwipeLeftComplete onSwipeRightComplete" touch-action="none">
	<template>
		<style>
			#container {
				position: relative;
				width: 100%;
				height: 50px;
				overflow: hidden;
			}
			#wrapper,
			#touchpad,
			#left,
			#right {
				position: absolute;
				top: 0;
				width: 100%;
				height: 100%;
			}
			#wrapper,
			#touchpad {
				left: 0;
			}
			#touchpad {
				z-index: 5;
				cursor: pointer;
			}
			#left {
				left: -100%;
			}
			#right {
				right: -100%;
			}
			.isReveal #left,
			.isReveal #right {
				left: 0;
				right: auto;
				z-index: 1;
			}
		</style>
		<div id="container" class="{{ {isReveal: isReveal} | tokenList }}" touch-action="none">
			<div id="wrapper">
				<div id="touchpad" touch-action="pan-y" on-tap="{{ _tapHandler }}">
					<content select="[touchpad]"></content>
				</div>
				<div id="left" touch-action="pan-y" on-tap="{{ _tapHandler }}">
					<content select="[left]"></content>
				</div>
				<div id="right" touch-action="pan-y" on-tap="{{ _tapHandler }}">
					<content select="[right]"></content>
				</div>
			</div>
		</div>
	</template>
	<script src="../jquery/dist/jquery.min.js"></script>
	<script>
		Polymer({
			publish: {
				tapHandler: null,
				touchpad: null,
				wrapper: null,
				animationTime: 400,
				xStartPosition: 0,
				xThreshold: 50,
				isReveal: false,
				startingZIndex: 0,
				touchTimeDifference: 100,
				allowedSwipeDirection: ['left','right'],
			},
			xPositionReset: function(cb) {
				var poly = this;
				poly.elAnimate.animate({
					left: 0
				}, poly.animationTime, function() {
					poly.xStartPosition = 0;
					if( cb ) cb();
				});
			},
			xPositionSnap: function(x,cb) {
				var poly = this;
				if( x > 0 ) {
					poly.elAnimate.animate({
						left: '100%'
					}, poly.animationTime, function() {
						poly.xStartPosition = poly.elAnimate.width();
						if( cb ) cb();
						if( poly.onSwipeLeftComplete ) poly.onSwipeLeftComplete.apply(poly,arguments);
					});
				} else {
					poly.elAnimate.animate({
						left: '-100%'
					}, poly.animationTime, function() {
						poly.xStartPosition = - poly.elAnimate.width();
						if( cb ) cb();
						if( poly.onSwipeRightComplete ) poly.onSwipeRightComplete.apply(poly,arguments);
					});
				}
			},
			onTrackstart: function(event) {
				if( this.xStartPosition == 0 ) this.xStartPosition = event.clientX;
			},
			onTrack: function(event) {
				var dif = event.clientX - this.xStartPosition;
				this.$.left.style.zIndex = this.startingZIndex - 1;
				this.$.right.style.zIndex = this.startingZIndex - 1;
				if( dif > 0 && _.indexOf(this.allowedSwipeDirection,'right') != -1 ) {
					this.$.left.style.zIndex = this.startingZIndex;
					this.elAnimate.css({left: dif});
				} else if( dif < 0 && _.indexOf(this.allowedSwipeDirection,'left') != -1 ) {
					this.$.right.style.zIndex = this.startingZIndex;
					this.elAnimate.css({left: dif});
				}
			},
			onTrackend: function(event,b,c) {
        console.log(event)
				var dif = event.clientX - this.xStartPosition;
				if( Math.abs(dif) >= this.xThreshold && (
					// ( dif > 0 && _.indexOf(this.allowedSwipeDirection,'left') != -1 ) &&
					( dif < 0 && _.indexOf(this.allowedSwipeDirection,'left') != -1 ) ||
					( dif > 0 && _.indexOf(this.allowedSwipeDirection,'right') != -1 )
				)) {
          event.preventTap();
					if( dif > 0 && this.onSwipeRight ) {
						this.onSwipeRight.apply(this,arguments);
					}
					if( dif < 0 && this.onSwipeLeft ) {
						this.onSwipeLeft.apply(this,arguments);
					}
					this.xPositionSnap.apply(this,[dif]);
				} else {
					this.xPositionReset.apply(this);
				}
			},
			_tapHandler: function(e, d, h) {
        e.srcElement = this;
				this._tap = [e, d, h];

        if(this.tapHandler) this.tapHandler(e, d, this)
			},
			ready: function() {
				var poly = this;
				this.touchpad = $(this.$.touchpad);
				this.$.touchpad.style.zIndex = this.startingZIndex;
				if( this.isReveal ) {
					this.elAnimate = this.touchpad;
					this.$.left.style.zIndex = this.startingZIndex - 1;
					this.$.right.style.zIndex = this.startingZIndex - 1;
				} else {
					this.elAnimate = $(this.$.wrapper);
					this.$.touchpad.style.zIndex = this.startingZIndex;
					this.$.left.style.zIndex = this.startingZIndex;
					this.$.right.style.zIndex = this.startingZIndex;
				}
				poly._isTrack = false;
				PolymerGestures.addEventListener(this.$.wrapper,'trackstart',function(){
					poly._isTrack = true;
					poly.onTrackstart.apply(poly,arguments);
				});
				PolymerGestures.addEventListener(this.$.wrapper,'track',function(){
					poly.onTrack.apply(poly,arguments);
				});
				PolymerGestures.addEventListener(this.$.wrapper,'trackend',function(){
					poly._isTrack = false;
					poly.onTrackend.apply(poly,arguments);
				});

				// var touchStart, touchTimeDifference;
				// if( poly.tapHandler ) {
				// 	$(this.$.touchpad)
				// 		.on('touchend mouseup', function(e){
				// 			if( ! poly._isTrack ) {
				// 				poly.async(function(){
				// 					poly.tapHandler.apply(poly,poly._tap);
				// 				},null,100);
				// 			}
				// 		});
				// }
			},
			close: function() {
				this.xPositionReset();
			},
		});
	</script>
</polymer-element>

