<!--
@element tcg-swipe
@author designbyraychou
@homepage https://github.com/the-control-group/tcg-swipe

**This element is compatible with Polymer 0.5.**

__Example:__

```
	<tcg-swipe id="swipe" isReveal="{{ isReveal }}" xThreshold="{{ xThreshold }}" animationTime="{{ animationTime }}">
		<div touchpad>Overlay Content</div>
		<div left>
			Left Content
			<a href="#" class="close" on-tap="{{ close }}">Close</a>
		</div>
		<div right>
			Right Content
			<a href="#" class="close" on-tap="{{ close }}">Close</a>
		</div>
	</tcg-swipe>
```
# Attributes

#### `isReveal`

Boolean that determines if the left and right content is position right below the touchpad. If `false`, left and right content moves with the touchpad.

#### `xThreshold`

Number that determines if it'll reveal the full content on trackend event. Default is `50` px

#### `animationTime`

Number in milliseconds for animation length

# Methods

#### `close`

Resets the positions

-->
<link rel="import" href="../polymer/polymer.html">
<polymer-element name="tcg-swipe" attributes="isReveal xThreshold animationTime allowedSwipeDirection startingZIndex onSwipeLeft onSwipeRight onSwipeLeftComplete onSwipeRightComplete tapHandler">
	<template>
		<style>
			#container {
				position: relative;
				width: 100%;
				height: 50px;
				overflow: hidden;
			}
			#wrapper,
			#touchpad,
			#left,
			#right {
				position: absolute;
				top: 0;
				width: 100%;
				height: 100%;
			}
			#wrapper,
			#touchpad {
				left: 0;
			}
			#touchpad {
				z-index: 5;
				cursor: pointer;
			}
			#left {
				left: -100%;
			}
			#right {
				right: -100%;
			}
			.isReveal #left,
			.isReveal #right {
				left: 0;
				right: auto;
				z-index: 1;
			}
		</style>
		<div id="container" class="{{ {isReveal: isReveal} | tokenList }}" touch-action="none">
			<div id="wrapper">
				<div id="touchpad" touch-action="pan-y">
					<content select="[touchpad]"></content>
				</div>
				<div id="left" touch-action="pan-y">
					<content select="[left]"></content>
				</div>
				<div id="right" touch-action="pan-y">
					<content select="[right]"></content>
				</div>
			</div>
		</div>
	</template>
	<script src="../jquery/dist/jquery.min.js"></script>
	<script>
		Polymer({
			publish: {
				tapHandler: null,
				touchpad: null,
				wrapper: null,
				animationTime: 400,
				xStartPosition: 0,
				xThreshold: 50,
				isReveal: false,
				startingZIndex: 0,
				touchTimeDifference: 100,
				allowedSwipeDirection: ['left','right'],
			},
			xPositionReset: function(cb) {
				var poly = this;
				var startTime;
				var startPosition = poly.elAnimate[0].getBoundingClientRect().left;
				function step(timestamp) {
					if( !startTime ) startTime = timestamp;
					progress = (timestamp - startTime) / poly.animationTime;
					var position = startPosition - (progress * startPosition);
					if( progress >= 1 ) {
						position = 0;
					}
					poly.elAnimate[0].style.webkitTransform = 'translate('+position+'px,0)';
					poly.elAnimate[0].style.transform = 'translate('+position+'px,0)';
					if( progress < 1 ) {
						window.requestAnimationFrame(step);
					} else {
						poly.xStartPosition = poly.elAnimate.width();
						if( cb ) cb();
						if( poly.onSwipeLeftComplete ) poly.onSwipeLeftComplete.apply(poly,arguments);
					}
				}
				window.requestAnimationFrame(step);
			},
			xPositionSnap: function(x,cb) {
				var poly = this;
				var startTime;
				var startProgress = poly.elAnimate[0].getBoundingClientRect().left / poly.elAnimate.width();
				function step(timestamp) {
					if( !startTime ) startTime = timestamp;
					progress = ((timestamp - startTime ) / poly.animationTime) + Math.abs(startProgress);
					var position;
					if( x < 0 ) {
						position = progress >= 1 ? -100 : -progress*100;
					} else {
						position = progress >= 1 ? 100 : progress*100;
					}
					poly.elAnimate[0].style.webkitTransform = 'translate('+position+'%,0)';
					poly.elAnimate[0].style.transform = 'translate('+position+'%,0)';
					if( progress < 1 ) {
						window.requestAnimationFrame(step);
					} else {
						poly.xStartPosition = poly.elAnimate.width();
						if( cb ) cb();
						if( poly.onSwipeLeftComplete ) poly.onSwipeLeftComplete.apply(poly,arguments);
					}
				}
				window.requestAnimationFrame(step);
			},
			onTrackstart: function(event) {
				if( this.xStartPosition == 0 ) this.xStartPosition = event.clientX;
			},
			onTrack: function(event) {
				var poly = this;
				var dif = event.clientX - this.xStartPosition;
				this.$.left.style.zIndex = this.startingZIndex - 1;
				this.$.right.style.zIndex = this.startingZIndex - 1;
				function follow() {
					poly.elAnimate[0].style.webkitTransform = 'translate('+dif+'px,0)';
					poly.elAnimate[0].style.transform = 'translate('+dif+'px,0)';
				}
				if( dif > 0 && _.indexOf(this.allowedSwipeDirection,'right') != -1 ) {
					this.$.left.style.zIndex = this.startingZIndex;
					follow();
				} else if( dif < 0 && _.indexOf(this.allowedSwipeDirection,'left') != -1 ) {
					this.$.right.style.zIndex = this.startingZIndex;
					follow();
				}
			},
			onTrackend: function(event,b,c) {
				var dif = event.clientX - this.xStartPosition;
				if( Math.abs(dif) >= this.xThreshold && (
					( dif < 0 && _.indexOf(this.allowedSwipeDirection,'left') != -1 ) ||
					( dif > 0 && _.indexOf(this.allowedSwipeDirection,'right') != -1 )
				)) {
					if( dif > 0 && this.onSwipeRight ) {
						this.onSwipeRight.apply(this,arguments);
					}
					if( dif < 0 && this.onSwipeLeft ) {
						this.onSwipeLeft.apply(this,arguments);
					}
					this.xPositionSnap.apply(this,[dif]);
				} else {
					this.xPositionReset.apply(this);
				}
			},
			ready: function() {
				var poly = this;
				this.touchpad = $(this.$.touchpad);
				this.$.touchpad.style.zIndex = this.startingZIndex;
				if( this.isReveal ) {
					this.elAnimate = this.touchpad;
					this.$.left.style.zIndex = this.startingZIndex - 1;
					this.$.right.style.zIndex = this.startingZIndex - 1;
				} else {
					this.elAnimate = $(this.$.wrapper);
					this.$.touchpad.style.zIndex = this.startingZIndex;
					this.$.left.style.zIndex = this.startingZIndex;
					this.$.right.style.zIndex = this.startingZIndex;
				}
				PolymerGestures.addEventListener(this.$.touchpad,'trackstart',function(){
					poly.onTrackstart.apply(poly,arguments);
				});
				PolymerGestures.addEventListener(this.$.touchpad,'track',function(){
					poly.onTrack.apply(poly,arguments);
				});
				PolymerGestures.addEventListener(this.$.touchpad,'trackend',function(){
					poly.onTrackend.apply(poly,arguments);
				});

				var touchStart, touchTimeDifference;
				if( poly.tapHandler ) {
					var el = $(this.$.touchpad);
					function startTrack(e) {
						touchTime = new Date();
					}
					function endTrack(e) {
						var touchTimeDifference = new Date() - touchTime;
						if (touchTimeDifference < poly.touchTimeDifference ) {
							poly.tapHandler(e);
						}
					}
					if( !!('ontouchstart' in window) ) {
						el
							.on('touchstart', startTrack)
							.on('touchend', endTrack);
					} else {
						el
							.on('mousedown', startTrack)
							.on('mouseup', endTrack);
					}
				}
			},
			close: function() {
				this.xPositionReset();
			},
		});
	</script>
</polymer-element>